#!@@PERL@@
# -*- cperl -*-

=head1 NAME

cpu - Plugin to monitor CPU usage.

=head1 APPLICABLE SYSTEMS

All Linux systems

=head1 CONFIGURATION

The following is default configuration

  [cpu]
	env.HZ	100

See "BUGS" for a explanation of this setting.

=head2 EXAMPLE WARNING AND CRITICAL SETTINGS

You can also set warning and critical levels for each of the data
series the plugin reports.  The following environment variables are
used as default for all fields:

  env.warning
  env.critical

But each field can be controlled separately:

  env.system_warning
  env.system_critical

  env.user_warning
  env.user_critical

  env.nice_warning
  env.nice_critical

  env.idle_warning
  env.idle_critical

For some kernels there is also the following settings:

  env.iowait_warning
  env.iowait_critical
  env.irq_warning
  env.irq_critical
  env.softirq_warning
  env.softirq_critical
  env.steal_warning
  env.steal_critical
  env.guest_warning
  env.guest_critical

=head1 INTERPRETATION

The plugin shows cpu usage in percent. In case of more than one core
it displays 100% for each core.

If a core is 100% busy there will be no "iowait" showing, that only
shows if the CPU has nothing else to do while it waits on IO.
Therefore a 100% busy core can hide a lot of iowait.  Please refer to
the IO latency and other disk related graphs for further information
about IO performance.

=head1 MAGIC MARKERS

  #%# family=auto
  #%# capabilities=autoconf

=head1 BUGS

Some combinations of hardware and Linux (probably only 2.4 kernels)
use 1000 units/second in /proc/stat corresponding to the systems
HZ. (see /usr/src/linux/include/asm/param.h). But Almost all systems
use 100 units/second and this is our default. Even if
Documentation/proc.txt in the kernel source says otherwise. - Finding
and fix by dz@426.ch

Otherwise none known

=head1 AUTHOR

Copyright (C) 2013 Diego Elio PettenÃ²
Rewritten from unknown author

=head1 LICENSE

GPLv2

=cut

use strict;
use Munin::Plugin;

my $HZ = $ENV{HZ} || 100;

my @statlines = split("\n", readfile("/proc/stat"));
my $ncpu = scalar(grep(/^cpu[0-9]+ /, @statlines));

my @totals = split(' ', $statlines[0]);
shift(@totals);
my $columns = scalar(@totals);

my @fields = qw(system user nice idle iowait irq softirq steal guest guest_nice);
my %data;
@data{@fields} = @totals;

my %field_info =
  (
   "system" => "CPU time spent by the kernel in system activities",
   "user"   => "CPU time spent by normal programs and daemons",
   "nice"   => "CPU time spent by nice(1)d programs",
   "idle"   => "Idle CPU time",
   "iowait" => "CPU time spent waiting for I/O operations to finish when there is nothing else to do",
   "irq"    => "CPU time spent handling interrupts",
   "softirq"=> "CPU time spent handling \"batched\" interrupts",
   "steal"  => "The time that a virtual CPU had runnable tasks, but the virtual CPU itself was not running",
   "guest"  => "The time spent running a virtual CPU for guest operating systems",
   "guest_nice" => "The time spent running a virtual CPU for a niced guest operating system"
  );

if ( defined $ARGV[0] and $ARGV[0] eq 'autoconf' ) {
  print @statlines ? "yes\n" : "no\n";
  exit 0;
} elsif ( defined $ARGV[0] and $ARGV[0] eq 'config' ) {
  my $graphlimit = $ncpu * 100;

print <<END;
graph_title CPU usage
graph_args --base 1000 -r --lower-limit 0 --upper-limit $graphlimit
graph_vlabel %
graph_scale no
graph_info This graph shows how CPU time is spent.
graph_category system
graph_period second
END

  foreach my $field (@fields) {
    last unless defined($data{$field});

    my $info = $field_info{$field};

    print <<END;
$field.label $field
$field.min 0
$field.max $graphlimit
$field.draw AREASTACK
$field.type DERIVE
$field.info $info
END

    adjust_threshold($field, $graphlimit);
    print_thresholds($field);
  }

  unless ( ($ENV{MUNIN_CAP_DIRTYCONFIG} || 0) == 1 ) {
    exit 0;
  }
}

foreach my $field (@fields) {
  last unless defined($data{$field});
  my $value = ($data{$field} * 100)/$HZ;

  print "$field.value $value\n";
}
